{"version":3,"sources":["skylark-domx-plugins-dnd.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-domx-plugins-dnd.js","sourcesContent":["define('skylark-domx-plugins-dnd/dnd',[\r\n    \"skylark-domx-plugins-base/plugins\"\r\n], function(plugins) {\r\n\r\n\treturn plugins.dnd = {};\r\n});\r\n\r\n\ndefine('skylark-domx-plugins-dnd/fallback/data-transfer',[],function(){\r\n    'use strict';\r\n\r\n    /**\r\n     * Object used to hold the data that is being dragged during drag and drop operations.\r\n     *\r\n     * It may hold one or more data items of different types. For more information about\r\n     * drag and drop operations and data transfer objects, see\r\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer\">HTML Drag and Drop API</a>.\r\n     *\r\n     * This object is created automatically by the @see:DragDropTouch singleton and is\r\n     * accessible through the @see:dataTransfer property of all drag events.\r\n     */\r\n\r\n    function DataTransfer() {\r\n        this._dropEffect = 'move';\r\n        this._effectAllowed = 'all';\r\n        this._data = {};\r\n    }\r\n    Object.defineProperty(DataTransfer.prototype, \"dropEffect\", {\r\n        /**\r\n         * Gets or sets the type of drag-and-drop operation currently selected.\r\n         * The value must be 'none',  'copy',  'link', or 'move'.\r\n         */\r\n        get: function () {\r\n            return this._dropEffect;\r\n        },\r\n        set: function (value) {\r\n            this._dropEffect = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DataTransfer.prototype, \"effectAllowed\", {\r\n        /**\r\n         * Gets or sets the types of operations that are possible.\r\n         * Must be one of 'none', 'copy', 'copyLink', 'copyMove', 'link',\r\n         * 'linkMove', 'move', 'all' or 'uninitialized'.\r\n         */\r\n        get: function () {\r\n            return this._effectAllowed;\r\n        },\r\n        set: function (value) {\r\n            this._effectAllowed = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DataTransfer.prototype, \"types\", {\r\n        /**\r\n         * Gets an array of strings giving the formats that were set in the @see:dragstart event.\r\n         */\r\n        get: function () {\r\n            return Object.keys(this._data);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Removes the data associated with a given type.\r\n     *\r\n     * The type argument is optional. If the type is empty or not specified, the data\r\n     * associated with all types is removed. If data for the specified type does not exist,\r\n     * or the data transfer contains no data, this method will have no effect.\r\n     *\r\n     * @param type Type of data to remove.\r\n     */\r\n    DataTransfer.prototype.clearData = function (type) {\r\n        if (type != null) {\r\n            delete this._data[type];\r\n        }\r\n        else {\r\n            this._data = null;\r\n        }\r\n    };\r\n    /**\r\n     * Retrieves the data for a given type, or an empty string if data for that type does\r\n     * not exist or the data transfer contains no data.\r\n     *\r\n     * @param type Type of data to retrieve.\r\n     */\r\n    DataTransfer.prototype.getData = function (type) {\r\n        return this._data[type] || '';\r\n    };\r\n    /**\r\n     * Set the data for a given type.\r\n     *\r\n     * For a list of recommended drag types, please see\r\n     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types.\r\n     *\r\n     * @param type Type of data to add.\r\n     * @param value Data to add.\r\n     */\r\n    DataTransfer.prototype.setData = function (type, value) {\r\n        this._data[type] = value;\r\n    };\r\n    /**\r\n     * Set the image to be used for dragging if a custom one is desired.\r\n     *\r\n     * @param img An image element to use as the drag feedback image.\r\n     * @param offsetX The horizontal offset within the image.\r\n     * @param offsetY The vertical offset within the image.\r\n     */\r\n    DataTransfer.prototype.setDragImage = function (img, offsetX, offsetY) {\r\n        this._imgCustom = img;\r\n        this._imgOffset = { x: offsetX, y: offsetY };\r\n    };\r\n\r\n    return DataTransfer;\r\n});\ndefine('skylark-domx-plugins-dnd/fallback/moused-drag-drop',[\r\n    \"skylark-langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-query\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-plugins-scrolls/auto-scroll\",\r\n    \"./data-transfer\"\r\n],function(\r\n    langx,\r\n    noder,\r\n    $,\r\n    eventer,\r\n    styler,\r\n    finder,\r\n    AutoScroll,\r\n    DataTransfer\r\n){\r\n    'use strict';\r\n\r\n    var MousedDragDrop = langx.Emitter.inherit({\r\n        /**\r\n         * Initializes the single instance of the @see:MousedDragDrop class.\r\n         */\r\n        _construct : function(dnd,dragSource,ptDown) {\r\n            this.dnd = dnd;\r\n            this._dragSource  =dragSource;\r\n            this._ptDown = ptDown;\r\n\r\n\r\n            this._lastClick = 0;\r\n            this._isDragEnabled = true;\r\n            this._dataTransfer = new DataTransfer();\r\n\r\n\r\n\r\n            var $doc = $(document);\r\n\r\n            this.listenTo($doc,\"mousemove\",this._onMouseMove);\r\n            this.listenTo($doc,\"mouseup\",this._onMouseUp);\r\n\r\n        },\r\n\r\n        _onMouseMove : function (e) {\r\n            if (this._shouldCancelPressHoldMove(e)) {\r\n              this._reset();\r\n              return;\r\n            }\r\n            if (this._shouldHandleMove(e) || this._shouldHandlePressHoldMove(e)) {\r\n                var target = this._getTarget(e);\r\n\r\n                // start dragging\r\n                if (this._dragSource && !this._img && this._shouldStartDragging(e)) {\r\n                    this._dispatchEvent(e, 'dragstart', this._dragSource);\r\n                    this._createImage(e);\r\n                    this._dispatchEvent(e, 'dragenter', target);\r\n                }\r\n                // continue dragging\r\n                if (this._img) {\r\n                    this._lastTouch = e;\r\n                    e.preventDefault(); // prevent scrolling\r\n                    if (target != this._lastTarget) {\r\n                        this._dispatchEvent(this._lastTouch, 'dragleave', this._lastTarget);\r\n                        this._dispatchEvent(e, 'dragenter', target);\r\n                        this._lastTarget = target;\r\n                    }\r\n                    this._moveImage(e);\r\n                    this._isDropZone = this._dispatchEvent(e, 'dragover', target);\r\n                }\r\n\r\n                this._handleAutoScroll(e);\r\n\r\n            }\r\n        },\r\n\r\n        _onMouseUp : function (e) {\r\n            if (this._shouldHandle(e)) {\r\n                // finish dragging\r\n                this._destroyImage();\r\n                if (this._dragSource) {\r\n                    if (e.type.indexOf('cancel') < 0 && this._isDropZone) {\r\n                        this._dispatchEvent(this._lastTouch, 'drop', this._lastTarget);\r\n                    }\r\n                    this._dispatchEvent(this._lastTouch, 'dragend', this._dragSource);\r\n                }\r\n            }\r\n            this.destroy();\r\n        },\r\n\r\n        // ** utilities\r\n        // ignore events that have been handled or that involve more than one touch\r\n        _shouldHandle : function (e) {\r\n            return e &&\r\n                !e.defaultPrevented ;\r\n        },\r\n\r\n        // use regular condition outside of press & hold mode\r\n        _shouldHandleMove : function (e) {\r\n          return !MousedDragDrop._ISPRESSHOLDMODE && this._shouldHandle(e);\r\n        },\r\n\r\n        // allow to handle moves that involve many touches for press & hold\r\n        _shouldHandlePressHoldMove : function (e) {\r\n          return MousedDragDrop._ISPRESSHOLDMODE &&  this._isDragEnabled ;\r\n        },\r\n\r\n        // reset data if user drags without pressing & holding\r\n        _shouldCancelPressHoldMove : function (e) {\r\n          return MousedDragDrop._ISPRESSHOLDMODE && !this._isDragEnabled &&\r\n              this._getDelta(e) > MousedDragDrop._PRESSHOLDMARGIN;\r\n        },\r\n\r\n        // start dragging when specified delta is detected\r\n        _shouldStartDragging : function (e) {\r\n            var delta = this._getDelta(e);\r\n            return delta > MousedDragDrop._THRESHOLD ||\r\n                (MousedDragDrop._ISPRESSHOLDMODE && delta >= MousedDragDrop._PRESSHOLDTHRESHOLD);\r\n        },\r\n\r\n        // clear all members\r\n        _reset : function () {\r\n            this._destroyImage();\r\n            this._dragSource = null;\r\n            this._lastTouch = null;\r\n            this._lastTarget = null;\r\n            this._ptDown = null;\r\n            this._isDragEnabled = false;\r\n            this._isDropZone = false;\r\n            this._dataTransfer = null;\r\n            clearInterval(this._pressHoldInterval);\r\n\r\n\r\n            if (this.pointerElemChangedInterval){\r\n                clearInterval(this.pointerElemChangedInterval); \r\n                this.pointerElemChangedInterval = null\r\n            } \r\n            if (this.autoscroller) {\r\n                this.autoscroller.destroy();\r\n                this.autoscroller = null;               \r\n            }\r\n        },\r\n\r\n        // get point for a touch event\r\n        _getPoint : function (e, page) {\r\n             return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };\r\n        },\r\n\r\n        // get distance between the current touch event and the first one\r\n        _getDelta : function (e) {\r\n            if (MousedDragDrop._ISPRESSHOLDMODE && !this._ptDown) { return 0; }\r\n            var p = this._getPoint(e);\r\n            return Math.abs(p.x - this._ptDown.x) + Math.abs(p.y - this._ptDown.y);\r\n        },\r\n\r\n        // get the element at a given touch event\r\n        _getTarget : function (e) {\r\n            var pt = this._getPoint(e), el = document.elementFromPoint(pt.x, pt.y);\r\n            while (el && getComputedStyle(el).pointerEvents == 'none') {\r\n                el = el.parentElement;\r\n            }\r\n            return el;\r\n        },\r\n\r\n        // create drag image from source element\r\n        _createImage : function (e) {\r\n            // just in case...\r\n            if (this._img) {\r\n                this._destroyImage();\r\n            }\r\n            // create drag image from custom element or drag source\r\n            this._imgCustom = this._dataTransfer._imgCustom;\r\n            this._imgOffset = this._dataTransfer._imgOffset;\r\n\r\n            var src = this._imgCustom || this._dragSource;\r\n            this._img = src.cloneNode(true);\r\n            this._copyStyle(src, this._img);\r\n            this._img.style.top = this._img.style.left = '-9999px';\r\n            // if creating from drag source, apply offset and opacity\r\n            if (!this._imgCustom) {\r\n                var rc = src.getBoundingClientRect(), \r\n                    pt = this._getPoint(e);\r\n\r\n                this._imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };\r\n                this._img.style.opacity = MousedDragDrop._OPACITY.toString();\r\n            }\r\n            // add image to document\r\n            this._moveImage(e);\r\n            document.body.appendChild(this._img);\r\n        },\r\n\r\n        // dispose of drag image element\r\n        _destroyImage : function () {\r\n            if (this._img) {\r\n                noder.remove(this._img);\r\n            }\r\n            this._img = null;\r\n            this._imgCustom = null;\r\n        },\r\n\r\n        // move the drag image element\r\n        _moveImage : function (e) {\r\n            var _this = this;\r\n            langx.defer(function () {\r\n                if (_this._img) {\r\n                    var pt = _this._getPoint(e, true);\r\n                    styler.css(_this._img,{\r\n                        position : 'absolute',\r\n                        pointerEvents : 'none',\r\n                        zIndex : '999999',\r\n                        left : Math.round(pt.x - _this._imgOffset.x) + 'px',\r\n                        top : Math.round(pt.y - _this._imgOffset.y) + 'px'\r\n                    });\r\n                }\r\n            });\r\n        },\r\n\r\n        // copy properties from an object to another\r\n        _copyProps : function (dst, src, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n                var p = props[i];\r\n                dst[p] = src[p];\r\n            }\r\n        },\r\n\r\n        _copyStyle : function (src, dst) {\r\n            // remove potentially troublesome attributes\r\n            MousedDragDrop._rmvAtts.forEach(function (att) {\r\n                dst.removeAttribute(att);\r\n            });\r\n            // copy canvas content\r\n            if (src instanceof HTMLCanvasElement) {\r\n                var cSrc = src, cDst = dst;\r\n                cDst.width = cSrc.width;\r\n                cDst.height = cSrc.height;\r\n                cDst.getContext('2d').drawImage(cSrc, 0, 0);\r\n            }\r\n            // copy style (without transitions)\r\n            var cs = getComputedStyle(src);\r\n            for (var i = 0; i < cs.length; i++) {\r\n                var key = cs[i];\r\n                if (key.indexOf('transition') < 0) {\r\n                    dst.style[key] = cs[key];\r\n                }\r\n            }\r\n            dst.style.pointerEvents = 'none';\r\n            // and repeat for all children\r\n            for (var i = 0; i < src.children.length; i++) {\r\n                this._copyStyle(src.children[i], dst.children[i]);\r\n            }\r\n        },\r\n\r\n        _dispatchEvent : function (e, type, target) {\r\n            if (e && target) {\r\n                var evt = document.createEvent('Event'), t = e.touches ? e.touches[0] : e;\r\n                evt.initEvent(type, true, true);\r\n                evt.button = 0;\r\n                evt.which = evt.buttons = 1;\r\n                this._copyProps(evt, e, MousedDragDrop._kbdProps);\r\n                this._copyProps(evt, t, MousedDragDrop._ptProps);\r\n                evt.dataTransfer = this._dataTransfer;\r\n                target.dispatchEvent(evt);\r\n                return evt.defaultPrevented;\r\n            }\r\n            return false;\r\n        },\r\n\r\n        // gets an element's closest draggable ancestor\r\n        _closestDraggable : function (e) {\r\n            for (; e; e = e.parentElement) {\r\n                if (e.hasAttribute('data-draggable')) {\r\n                    return e;\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n\r\n        _handleAutoScroll: function(evt) {\r\n            var dnd = this.dnd;\r\n\r\n            var x = evt.clientX,\r\n                y = evt.clientY,\r\n\r\n                elem = document.elementFromPoint(x, y);\r\n\r\n\r\n            // Listener for pointer element change\r\n            ////var ogElemScroller = finder.scrollableParent(elem, true);\r\n            if (\r\n                (\r\n                    !this.pointerElemChangedInterval ||\r\n                    x !== this.lastPointerElemX ||\r\n                    y !== this.lastPointerElemY\r\n                )\r\n            ) {\r\n\r\n                if (this.pointerElemChangedInterval){\r\n                    clearInterval(this.pointerElemChangedInterval); \r\n                } \r\n                // Detect for pointer elem change, emulating native DnD behaviour\r\n                var ogElemScroller = null ;\r\n                this.pointerElemChangedInterval = setInterval(function() {\r\n                    // could also check if scroll direction on newElem changes due to parent autoscrolling\r\n                    var newElem = finder.scrollableParent(document.elementFromPoint(x, y), true);\r\n                    if (newElem !== ogElemScroller) {\r\n                        ogElemScroller = newElem;\r\n                        if (this.autoscroller) {\r\n                            this.autoscroller.destroy();\r\n                            this.autoscroller = null;\r\n                        }\r\n                        this.autoscroller = new AutoScroll(ogElemScroller,dnd.dragging.options);\r\n                        this.autoscroller.handle(x,y);\r\n                    }\r\n                }, 10);\r\n                this.lastPointerElemX = x;\r\n                this.lastPointerElemY = y;\r\n            }\r\n        },\r\n\r\n\r\n        destroy : function() {\r\n            this.unlistenTo();\r\n            this._reset();\r\n        }\r\n    });\r\n\r\n    // constants\r\n    MousedDragDrop._THRESHOLD = 5; // pixels to move before drag starts\r\n    MousedDragDrop._OPACITY = 0.5; // drag image opacity\r\n    MousedDragDrop._DBLCLICK = 500; // max ms between clicks in a double click\r\n    MousedDragDrop._CTXMENU = 900; // ms to hold before raising 'contextmenu' event\r\n    MousedDragDrop._ISPRESSHOLDMODE = false; // decides of press & hold mode presence\r\n    MousedDragDrop._PRESSHOLDAWAIT = 400; // ms to wait before press & hold is detected\r\n    MousedDragDrop._PRESSHOLDMARGIN = 25; // pixels that finger might shiver while pressing\r\n    MousedDragDrop._PRESSHOLDTHRESHOLD = 0; // pixels to move before drag starts\r\n    // copy styles/attributes from drag source to drag image element\r\n    MousedDragDrop._rmvAtts = 'id,class,style,draggable'.split(',');\r\n    // synthesize and dispatch an event\r\n    // returns true if the event has been handled (e.preventDefault == true)\r\n    MousedDragDrop._kbdProps = 'altKey,ctrlKey,metaKey,shiftKey'.split(',');\r\n    MousedDragDrop._ptProps = 'pageX,pageY,clientX,clientY,screenX,screenY'.split(',');\t\r\n\r\n    return MousedDragDrop\r\n});\ndefine('skylark-domx-plugins-dnd/manager',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-langx-hoster/is-mobile\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-data\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-styler\",\r\n    \"./dnd\",\r\n    \"./fallback/moused-drag-drop\"\r\n], function(langx, isMobile,noder, datax, finder, geom, eventer, styler,dnd,MousedDragDrop) {\r\n    var on = eventer.on,\r\n        off = eventer.off,\r\n        attr = datax.attr,\r\n        removeAttr = datax.removeAttr,\r\n        offset = geom.pagePosition,\r\n        addClass = styler.addClass,\r\n        height = geom.height;\r\n\r\n\r\n        // This will not pass for IE9, because IE9 DnD only works on anchors\r\n    var  supportDraggable = ('draggable' in document.createElement('div')) && !isMobile.apple.device; //TODO move to xxx\r\n\r\n\r\n    var Manager = dnd.Manager = langx.Evented.inherit({\r\n        klassName: \"Manager\",\r\n\r\n        init: function() {\r\n\r\n        },\r\n\r\n        prepare: function(draggable,event) {\r\n            var e = eventer.create(\"preparing\", {\r\n                dragSource: draggable.dragSource,\r\n                dragHandle: draggable.dragHandle,\r\n                originalEvent : event\r\n            });\r\n            draggable.trigger(e);\r\n            draggable.dragSource = e.dragSource;\r\n            draggable.dragHandle = e.dragHandle;\r\n\r\n\r\n            if (draggable.dragSource) {\r\n                this.useNativeDnd =  draggable.options.forceFallback ? false : supportDraggable;  \r\n                this.dragging = draggable;\r\n\r\n                datax.data(draggable.dragSource, \"draggable\", true);\r\n                if (this.useNativeDnd) {\r\n                    datax.attr(draggable.dragSource, \"draggable\", 'true');\r\n                } else {\r\n                    this._fallbacker = new MousedDragDrop(this,draggable.dragSource,draggable.startPos);\r\n                }\r\n\r\n                try {\r\n                    if (document.selection) {\r\n                       document.selection.empty();\r\n                    } else {\r\n                        window.getSelection().removeAllRanges();\r\n                    }\r\n                } catch (err) {\r\n                }\r\n            }\r\n        },\r\n\r\n        start: function(draggable, event) {\r\n            datax.data(draggable.dragSource, \"draggable\", false);\r\n            if (this.useNativeDnd) {\r\n                datax.attr(draggable.dragSource, \"draggable\", 'false');\r\n            }\r\n\r\n            var p = geom.pagePosition(draggable.dragSource);\r\n            this.draggingOffsetX = parseInt(event.pageX - p.left);\r\n            this.draggingOffsetY = parseInt(event.pageY - p.top)\r\n\r\n            var e = eventer.create(\"started\", {\r\n                elm: draggable.elm,\r\n                dragSource: draggable.dragSource,\r\n                dragHandle: draggable.dragHandle,\r\n                ghost: null,\r\n\r\n                originalEvent : event,\r\n\r\n                transfer: {}\r\n            });\r\n\r\n            draggable.trigger(e);\r\n\r\n\r\n            this.dragging = draggable;\r\n\r\n            if (draggable.draggingClass) {\r\n                styler.addClass(draggable.dragSource, draggable.draggingClass);\r\n            }\r\n\r\n            this.draggingGhost = e.ghost;\r\n            if (!this.draggingGhost) {\r\n                this.draggingGhost = draggable.dragSource;\r\n            }\r\n\r\n            this.draggingTransfer = e.transfer;\r\n            if (this.draggingTransfer) {\r\n\r\n                langx.each(this.draggingTransfer, function(key, value) {\r\n                    event.dataTransfer.setData(key, value);\r\n                });\r\n            }\r\n\r\n            event.dataTransfer.setDragImage(this.draggingGhost, this.draggingOffsetX, this.draggingOffsetY);\r\n\r\n            ///event.dataTransfer.effectAllowed = \"copyMove\";\r\n\r\n            var e1 = eventer.create(\"dndStarted\", {\r\n                elm: e.elm,\r\n                dragSource: e.dragSource,\r\n                dragHandle: e.dragHandle,\r\n                ghost: e.ghost,\r\n                transfer: e.transfer,\r\n                dragging : this.dragging\r\n            });\r\n\r\n            this.trigger(e1);\r\n        },\r\n\r\n        over: function() {\r\n\r\n        },\r\n\r\n        end: function(dropped) {\r\n            var dragging = this.dragging;\r\n            if (dragging) {\r\n                if (dragging.draggingClass) {\r\n                    styler.removeClass(dragging.dragSource, dragging.draggingClass);\r\n                }\r\n            }\r\n\r\n            var e2 = eventer.create(\"ended\", {\r\n                originalEvent : e\r\n            });\r\n\r\n            this.dragging.trigger(e2);\r\n\r\n\r\n            var e = eventer.create(\"dndEnded\", {});\r\n            this.trigger(e);\r\n\r\n\r\n            this.dragging = null;\r\n            this.draggingTransfer = null;\r\n            this.draggingGhost = null;\r\n            this.draggingOffsetX = null;\r\n            this.draggingOffsetY = null;\r\n        }\r\n    });\r\n\r\n    var manager = new Manager();\r\n\r\n\r\n    return manager;\r\n});\ndefine('skylark-domx-plugins-dnd/Draggable',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-data\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-devices-points/touch\",\r\n    \"skylark-domx-plugins-base\",\r\n    \"./dnd\",\r\n    \"./manager\"\r\n], function(langx, noder, datax, finder, geom, eventer, styler, touch, plugins, dnd,manager) {\r\n    var on = eventer.on,\r\n        off = eventer.off,\r\n        attr = datax.attr,\r\n        removeAttr = datax.removeAttr,\r\n        offset = geom.pagePosition,\r\n        addClass = styler.addClass,\r\n        height = geom.height;\r\n\r\n\r\n\r\n    var Draggable = plugins.Plugin.inherit({\r\n        klassName: \"Draggable\",\r\n        \r\n        pluginName : \"lark.dnd.draggable\",\r\n\r\n        options : {\r\n            draggingClass : \"dragging\",\r\n            forceFallback : false\r\n        },\r\n\r\n        _construct: function(elm, options) {\r\n            this.overrided(elm,options);\r\n\r\n            var self = this,\r\n                options = this.options;\r\n\r\n            self.draggingClass = options.draggingClass;\r\n\r\n            [\"preparing\", \"started\", \"ended\", \"moving\"].forEach(function(eventName) {\r\n                if (langx.isFunction(options[eventName])) {\r\n                    self.on(eventName, options[eventName]);\r\n                }\r\n            });\r\n\r\n            touch.mousy(elm);\r\n\r\n            eventer.on(elm, {\r\n                \"mousedown\": function(e) {\r\n                    var options = self.options;\r\n                    if (options.handle) {\r\n                        if (langx.isFunction(options.handle)) {\r\n                            self.dragHandle = options.handle(e.target,self._elm);\r\n                        } else {\r\n                            self.dragHandle = finder.closest(e.target, options.handle,self._elm);\r\n                        }\r\n                        if (!self.dragHandle) {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (options.source) {\r\n                        if (langx.isFunction(options.source)) {\r\n                            self.dragSource =  options.source(e.target, self._elm);                            \r\n                        } else {\r\n                            self.dragSource = finder.closest(e.target, options.source,self._elm);                            \r\n                        }\r\n                    } else {\r\n                        self.dragSource = self._elm;\r\n                    }\r\n\r\n                    self.startPos = {\r\n                        x : e.clientX,\r\n                        y : e.clientY\r\n                    };\r\n\r\n                    manager.prepare(self,e);\r\n\r\n                },\r\n\r\n                \"mouseup\": function(e) {\r\n                    ///if (self.dragSource) {\r\n                    ///    //datax.attr(self.dragSource, \"draggable\", 'false');\r\n                    ///    self.dragSource = null;\r\n                    ///    self.dragHandle = null;\r\n                    ///}\r\n                },\r\n\r\n                \"dragstart\": function(e) {\r\n                    if (manager.dragging !== self) {\r\n                        return;\r\n                    }\r\n                    manager.start(self, e);\r\n                },\r\n\r\n                \"dragend\": function(e) {\r\n                    if (manager.dragging !== self) {\r\n                        return;\r\n                    }\r\n                    eventer.stop(e);\r\n\r\n                    if (!manager.dragging) {\r\n                        return;\r\n                    }\r\n\r\n                    manager.end(false);\r\n                }\r\n            });\r\n\r\n        }\r\n\r\n    });\r\n\r\n    plugins.register(Draggable,\"draggable\");\r\n\r\n    return dnd.Draggable = Draggable;\r\n});\ndefine('skylark-domx-plugins-dnd/Droppable',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-data\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-plugins-base\",\r\n    \"./dnd\",\r\n    \"./manager\"\r\n], function(langx, noder, datax, finder, geom, eventer, styler, plugins, dnd,manager) {\r\n    var on = eventer.on,\r\n        off = eventer.off,\r\n        attr = datax.attr,\r\n        removeAttr = datax.removeAttr,\r\n        offset = geom.pagePosition,\r\n        addClass = styler.addClass,\r\n        height = geom.height;\r\n\r\n\r\n    var Droppable = plugins.Plugin.inherit({\r\n        klassName: \"Droppable\",\r\n\r\n        pluginName : \"lark.dnd.droppable\",\r\n\r\n        options : {\r\n            draggingClass : \"dragging\"\r\n        },\r\n\r\n        _construct: function(elm, options) {\r\n            this.overrided(elm,options);\r\n\r\n            var self = this,\r\n                options = self.options,\r\n                draggingClass = options.draggingClass,\r\n                hoverClass,\r\n                activeClass,\r\n                acceptable = true;\r\n\r\n            [\"started\", \"entered\", \"leaved\", \"dropped\", \"overing\"].forEach(function(eventName) {\r\n                if (langx.isFunction(options[eventName])) {\r\n                    self.on(eventName, options[eventName]);\r\n                }\r\n            });\r\n\r\n            eventer.on(elm, {\r\n                \"dragover\": function(e) {\r\n                    e.stopPropagation()\r\n\r\n                    if (!acceptable) {\r\n                        return\r\n                    }\r\n\r\n                    var e2 = eventer.create(\"overing\", {\r\n                        originalEvent : e,\r\n                        overElm: e.target,\r\n                        transfer: manager.draggingTransfer,\r\n                        acceptable: true\r\n                    });\r\n                    self.trigger(e2);\r\n\r\n                    if (e2.acceptable) {\r\n                        e.preventDefault() // allow drop\r\n\r\n                        ///e.dataTransfer.dropEffect = \"copyMove\";\r\n                    }\r\n\r\n                },\r\n\r\n                \"dragenter\": function(e) {\r\n                    var options = self.options,\r\n                        elm = self._elm;\r\n\r\n                    var e2 = eventer.create(\"entered\", {\r\n                        originalEvent : e,\r\n                        transfer: manager.draggingTransfer\r\n                    });\r\n\r\n                    self.trigger(e2);\r\n\r\n                    e.stopPropagation()\r\n\r\n                    if (hoverClass && acceptable) {\r\n                        styler.addClass(elm, hoverClass)\r\n                    }\r\n                },\r\n\r\n                \"dragleave\": function(e) {\r\n                    var options = self.options,\r\n                        elm = self._elm;\r\n                    if (!acceptable) return false\r\n\r\n                    var e2 = eventer.create(\"leaved\", {\r\n                        originalEvent : e,\r\n                        transfer: manager.draggingTransfer\r\n                    });\r\n\r\n                    self.trigger(e2);\r\n\r\n                    e.stopPropagation()\r\n\r\n                    if (hoverClass && acceptable) {\r\n                        styler.removeClass(elm, hoverClass);\r\n                    }\r\n                },\r\n\r\n                \"drop\": function(e) {\r\n                    var options = self.options,\r\n                        elm = self._elm;\r\n\r\n                    eventer.stop(e); // stops the browser from redirecting.\r\n\r\n                    if (!manager.dragging) return\r\n\r\n                    // manager.dragging.elm.removeClass('dragging');\r\n\r\n                    if (hoverClass && acceptable) {\r\n                        styler.addClass(elm, hoverClass)\r\n                    }\r\n\r\n                    var e2 = eventer.create(\"dropped\", {\r\n                        originalEvent : e,\r\n                        transfer: manager.draggingTransfer\r\n                    });\r\n\r\n                    self.trigger(e2);\r\n\r\n                    manager.end(true)\r\n                }\r\n            });\r\n\r\n            manager.on(\"dndStarted\", function(e) {\r\n                var e2 = eventer.create(\"started\", {\r\n                    transfer: manager.draggingTransfer,\r\n                    acceptable: false,\r\n                    dragging : e.dragging \r\n                });\r\n\r\n                self.trigger(e2);\r\n\r\n                acceptable = e2.acceptable;\r\n                hoverClass = e2.hoverClass;\r\n                activeClass = e2.activeClass;\r\n\r\n                if (activeClass && acceptable) {\r\n                    styler.addClass(elm, activeClass);\r\n                }\r\n\r\n            }).on(\"dndEnded\", function(e) {\r\n                var e2 = eventer.create(\"ended\", {\r\n                    transfer: manager.draggingTransfer,\r\n                    acceptable: false\r\n                });\r\n\r\n                self.trigger(e2);\r\n\r\n                if (hoverClass && acceptable) {\r\n                    styler.removeClass(elm, hoverClass);\r\n                }\r\n                if (activeClass && acceptable) {\r\n                    styler.removeClass(elm, activeClass);\r\n                }\r\n\r\n                acceptable = false;\r\n                activeClass = null;\r\n                hoverClass = null;\r\n            });\r\n\r\n        }\r\n    });\r\n\r\n    plugins.register(Droppable,\"droppable\");\r\n\r\n    return dnd.Droppable = Droppable;\r\n});\ndefine('skylark-domx-plugins-dnd/main',[\r\n    \"./dnd\",\r\n    \"./Draggable\",\r\n    \"./Droppable\"\r\n], function(dnd) {\r\n    return dnd;\r\n})\r\n;\ndefine('skylark-domx-plugins-dnd', ['skylark-domx-plugins-dnd/main'], function (main) { return main; });\n\n"]}