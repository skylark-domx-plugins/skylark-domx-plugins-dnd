{"version":3,"sources":["fallback/moused-drag-drop.js"],"names":["define","langx","noder","$","eventer","styler","finder","AutoScroll","DataTransfer","MousedDragDrop","Emitter","inherit","_construct","dnd","dragSource","ptDown","this","_dragSource","_ptDown","_lastClick","_isDragEnabled","_dataTransfer","$doc","document","listenTo","_onMouseMove","_onMouseUp","e","_shouldCancelPressHoldMove","_reset","_shouldHandleMove","_shouldHandlePressHoldMove","target","_getTarget","_img","_shouldStartDragging","_dispatchEvent","_createImage","_lastTouch","preventDefault","_lastTarget","_moveImage","_isDropZone","_handleAutoScroll","_shouldHandle","_destroyImage","type","indexOf","destroy","defaultPrevented","_ISPRESSHOLDMODE","_getDelta","_PRESSHOLDMARGIN","delta","_THRESHOLD","_PRESSHOLDTHRESHOLD","clearInterval","_pressHoldInterval","pointerElemChangedInterval","autoscroller","_getPoint","page","x","pageX","clientX","y","pageY","clientY","p","Math","abs","pt","el","elementFromPoint","getComputedStyle","pointerEvents","parentElement","_imgCustom","_imgOffset","src","cloneNode","_copyStyle","style","top","left","rc","getBoundingClientRect","opacity","_OPACITY","toString","body","appendChild","remove","_this","defer","css","position","zIndex","round","_copyProps","dst","props","i","length","_rmvAtts","forEach","att","removeAttribute","HTMLCanvasElement","cSrc","cDst","width","height","getContext","drawImage","cs","key","children","evt","createEvent","t","touches","initEvent","button","which","buttons","_kbdProps","_ptProps","dataTransfer","dispatchEvent","_closestDraggable","hasAttribute","lastPointerElemX","lastPointerElemY","ogElemScroller","setInterval","newElem","scrollableParent","dragging","options","handle","unlistenTo","_DBLCLICK","_CTXMENU","_PRESSHOLDAWAIT","split"],"mappings":"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","file":"../../fallback/moused-drag-drop.js","sourcesContent":["define([\r\n    \"skylark-langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-query\",\r\n    \"skylark-domx-eventer\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-plugins-scrolls/auto-scroll\",\r\n    \"./data-transfer\"\r\n],function(\r\n    langx,\r\n    noder,\r\n    $,\r\n    eventer,\r\n    styler,\r\n    finder,\r\n    AutoScroll,\r\n    DataTransfer\r\n){\r\n    'use strict';\r\n\r\n    var MousedDragDrop = langx.Emitter.inherit({\r\n        /**\r\n         * Initializes the single instance of the @see:MousedDragDrop class.\r\n         */\r\n        _construct : function(dnd,dragSource,ptDown) {\r\n            this.dnd = dnd;\r\n            this._dragSource  =dragSource;\r\n            this._ptDown = ptDown;\r\n\r\n\r\n            this._lastClick = 0;\r\n            this._isDragEnabled = true;\r\n            this._dataTransfer = new DataTransfer();\r\n\r\n\r\n\r\n            var $doc = $(document);\r\n\r\n            this.listenTo($doc,\"mousemove\",this._onMouseMove);\r\n            this.listenTo($doc,\"mouseup\",this._onMouseUp);\r\n\r\n        },\r\n\r\n        _onMouseMove : function (e) {\r\n            if (this._shouldCancelPressHoldMove(e)) {\r\n              this._reset();\r\n              return;\r\n            }\r\n            if (this._shouldHandleMove(e) || this._shouldHandlePressHoldMove(e)) {\r\n                var target = this._getTarget(e);\r\n\r\n                // start dragging\r\n                if (this._dragSource && !this._img && this._shouldStartDragging(e)) {\r\n                    this._dispatchEvent(e, 'dragstart', this._dragSource);\r\n                    this._createImage(e);\r\n                    this._dispatchEvent(e, 'dragenter', target);\r\n                }\r\n                // continue dragging\r\n                if (this._img) {\r\n                    this._lastTouch = e;\r\n                    e.preventDefault(); // prevent scrolling\r\n                    if (target != this._lastTarget) {\r\n                        this._dispatchEvent(this._lastTouch, 'dragleave', this._lastTarget);\r\n                        this._dispatchEvent(e, 'dragenter', target);\r\n                        this._lastTarget = target;\r\n                    }\r\n                    this._moveImage(e);\r\n                    this._isDropZone = this._dispatchEvent(e, 'dragover', target);\r\n                }\r\n\r\n                this._handleAutoScroll(e);\r\n\r\n            }\r\n        },\r\n\r\n        _onMouseUp : function (e) {\r\n            if (this._shouldHandle(e)) {\r\n                // finish dragging\r\n                this._destroyImage();\r\n                if (this._dragSource) {\r\n                    if (e.type.indexOf('cancel') < 0 && this._isDropZone) {\r\n                        this._dispatchEvent(this._lastTouch, 'drop', this._lastTarget);\r\n                    }\r\n                    this._dispatchEvent(this._lastTouch, 'dragend', this._dragSource);\r\n                }\r\n            }\r\n            this.destroy();\r\n        },\r\n\r\n        // ** utilities\r\n        // ignore events that have been handled or that involve more than one touch\r\n        _shouldHandle : function (e) {\r\n            return e &&\r\n                !e.defaultPrevented ;\r\n        },\r\n\r\n        // use regular condition outside of press & hold mode\r\n        _shouldHandleMove : function (e) {\r\n          return !MousedDragDrop._ISPRESSHOLDMODE && this._shouldHandle(e);\r\n        },\r\n\r\n        // allow to handle moves that involve many touches for press & hold\r\n        _shouldHandlePressHoldMove : function (e) {\r\n          return MousedDragDrop._ISPRESSHOLDMODE &&  this._isDragEnabled ;\r\n        },\r\n\r\n        // reset data if user drags without pressing & holding\r\n        _shouldCancelPressHoldMove : function (e) {\r\n          return MousedDragDrop._ISPRESSHOLDMODE && !this._isDragEnabled &&\r\n              this._getDelta(e) > MousedDragDrop._PRESSHOLDMARGIN;\r\n        },\r\n\r\n        // start dragging when specified delta is detected\r\n        _shouldStartDragging : function (e) {\r\n            var delta = this._getDelta(e);\r\n            return delta > MousedDragDrop._THRESHOLD ||\r\n                (MousedDragDrop._ISPRESSHOLDMODE && delta >= MousedDragDrop._PRESSHOLDTHRESHOLD);\r\n        },\r\n\r\n        // clear all members\r\n        _reset : function () {\r\n            this._destroyImage();\r\n            this._dragSource = null;\r\n            this._lastTouch = null;\r\n            this._lastTarget = null;\r\n            this._ptDown = null;\r\n            this._isDragEnabled = false;\r\n            this._isDropZone = false;\r\n            this._dataTransfer = null;\r\n            clearInterval(this._pressHoldInterval);\r\n\r\n\r\n            if (this.pointerElemChangedInterval){\r\n                clearInterval(this.pointerElemChangedInterval); \r\n                this.pointerElemChangedInterval = null\r\n            } \r\n            if (this.autoscroller) {\r\n                this.autoscroller.destroy();\r\n                this.autoscroller = null;               \r\n            }\r\n        },\r\n\r\n        // get point for a touch event\r\n        _getPoint : function (e, page) {\r\n             return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };\r\n        },\r\n\r\n        // get distance between the current touch event and the first one\r\n        _getDelta : function (e) {\r\n            if (MousedDragDrop._ISPRESSHOLDMODE && !this._ptDown) { return 0; }\r\n            var p = this._getPoint(e);\r\n            return Math.abs(p.x - this._ptDown.x) + Math.abs(p.y - this._ptDown.y);\r\n        },\r\n\r\n        // get the element at a given touch event\r\n        _getTarget : function (e) {\r\n            var pt = this._getPoint(e), el = document.elementFromPoint(pt.x, pt.y);\r\n            while (el && getComputedStyle(el).pointerEvents == 'none') {\r\n                el = el.parentElement;\r\n            }\r\n            return el;\r\n        },\r\n\r\n        // create drag image from source element\r\n        _createImage : function (e) {\r\n            // just in case...\r\n            if (this._img) {\r\n                this._destroyImage();\r\n            }\r\n            // create drag image from custom element or drag source\r\n            this._imgCustom = this._dataTransfer._imgCustom;\r\n            this._imgOffset = this._dataTransfer._imgOffset;\r\n\r\n            var src = this._imgCustom || this._dragSource;\r\n            this._img = src.cloneNode(true);\r\n            this._copyStyle(src, this._img);\r\n            this._img.style.top = this._img.style.left = '-9999px';\r\n            // if creating from drag source, apply offset and opacity\r\n            if (!this._imgCustom) {\r\n                var rc = src.getBoundingClientRect(), \r\n                    pt = this._getPoint(e);\r\n\r\n                this._imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };\r\n                this._img.style.opacity = MousedDragDrop._OPACITY.toString();\r\n            }\r\n            // add image to document\r\n            this._moveImage(e);\r\n            document.body.appendChild(this._img);\r\n        },\r\n\r\n        // dispose of drag image element\r\n        _destroyImage : function () {\r\n            if (this._img) {\r\n                noder.remove(this._img);\r\n            }\r\n            this._img = null;\r\n            this._imgCustom = null;\r\n        },\r\n\r\n        // move the drag image element\r\n        _moveImage : function (e) {\r\n            var _this = this;\r\n            langx.defer(function () {\r\n                if (_this._img) {\r\n                    var pt = _this._getPoint(e, true);\r\n                    styler.css(_this._img,{\r\n                        position : 'absolute',\r\n                        pointerEvents : 'none',\r\n                        zIndex : '999999',\r\n                        left : Math.round(pt.x - _this._imgOffset.x) + 'px',\r\n                        top : Math.round(pt.y - _this._imgOffset.y) + 'px'\r\n                    });\r\n                }\r\n            });\r\n        },\r\n\r\n        // copy properties from an object to another\r\n        _copyProps : function (dst, src, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n                var p = props[i];\r\n                dst[p] = src[p];\r\n            }\r\n        },\r\n\r\n        _copyStyle : function (src, dst) {\r\n            // remove potentially troublesome attributes\r\n            MousedDragDrop._rmvAtts.forEach(function (att) {\r\n                dst.removeAttribute(att);\r\n            });\r\n            // copy canvas content\r\n            if (src instanceof HTMLCanvasElement) {\r\n                var cSrc = src, cDst = dst;\r\n                cDst.width = cSrc.width;\r\n                cDst.height = cSrc.height;\r\n                cDst.getContext('2d').drawImage(cSrc, 0, 0);\r\n            }\r\n            // copy style (without transitions)\r\n            var cs = getComputedStyle(src);\r\n            for (var i = 0; i < cs.length; i++) {\r\n                var key = cs[i];\r\n                if (key.indexOf('transition') < 0) {\r\n                    dst.style[key] = cs[key];\r\n                }\r\n            }\r\n            dst.style.pointerEvents = 'none';\r\n            // and repeat for all children\r\n            for (var i = 0; i < src.children.length; i++) {\r\n                this._copyStyle(src.children[i], dst.children[i]);\r\n            }\r\n        },\r\n\r\n        _dispatchEvent : function (e, type, target) {\r\n            if (e && target) {\r\n                var evt = document.createEvent('Event'), t = e.touches ? e.touches[0] : e;\r\n                evt.initEvent(type, true, true);\r\n                evt.button = 0;\r\n                evt.which = evt.buttons = 1;\r\n                this._copyProps(evt, e, MousedDragDrop._kbdProps);\r\n                this._copyProps(evt, t, MousedDragDrop._ptProps);\r\n                evt.dataTransfer = this._dataTransfer;\r\n                target.dispatchEvent(evt);\r\n                return evt.defaultPrevented;\r\n            }\r\n            return false;\r\n        },\r\n\r\n        // gets an element's closest draggable ancestor\r\n        _closestDraggable : function (e) {\r\n            for (; e; e = e.parentElement) {\r\n                if (e.hasAttribute('data-draggable')) {\r\n                    return e;\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n\r\n        _handleAutoScroll: function(evt) {\r\n            var dnd = this.dnd;\r\n\r\n            var x = evt.clientX,\r\n                y = evt.clientY,\r\n\r\n                elem = document.elementFromPoint(x, y);\r\n\r\n\r\n            // Listener for pointer element change\r\n            ////var ogElemScroller = finder.scrollableParent(elem, true);\r\n            if (\r\n                (\r\n                    !this.pointerElemChangedInterval ||\r\n                    x !== this.lastPointerElemX ||\r\n                    y !== this.lastPointerElemY\r\n                )\r\n            ) {\r\n\r\n                if (this.pointerElemChangedInterval){\r\n                    clearInterval(this.pointerElemChangedInterval); \r\n                } \r\n                // Detect for pointer elem change, emulating native DnD behaviour\r\n                var ogElemScroller = null ;\r\n                this.pointerElemChangedInterval = setInterval(function() {\r\n                    // could also check if scroll direction on newElem changes due to parent autoscrolling\r\n                    var newElem = finder.scrollableParent(document.elementFromPoint(x, y), true);\r\n                    if (newElem !== ogElemScroller) {\r\n                        ogElemScroller = newElem;\r\n                        if (this.autoscroller) {\r\n                            this.autoscroller.destroy();\r\n                            this.autoscroller = null;\r\n                        }\r\n                        this.autoscroller = new AutoScroll(ogElemScroller,dnd.dragging.options);\r\n                        this.autoscroller.handle(x,y);\r\n                    }\r\n                }, 10);\r\n                this.lastPointerElemX = x;\r\n                this.lastPointerElemY = y;\r\n            }\r\n        },\r\n\r\n\r\n        destroy : function() {\r\n            this.unlistenTo();\r\n            this._reset();\r\n        }\r\n    });\r\n\r\n    // constants\r\n    MousedDragDrop._THRESHOLD = 5; // pixels to move before drag starts\r\n    MousedDragDrop._OPACITY = 0.5; // drag image opacity\r\n    MousedDragDrop._DBLCLICK = 500; // max ms between clicks in a double click\r\n    MousedDragDrop._CTXMENU = 900; // ms to hold before raising 'contextmenu' event\r\n    MousedDragDrop._ISPRESSHOLDMODE = false; // decides of press & hold mode presence\r\n    MousedDragDrop._PRESSHOLDAWAIT = 400; // ms to wait before press & hold is detected\r\n    MousedDragDrop._PRESSHOLDMARGIN = 25; // pixels that finger might shiver while pressing\r\n    MousedDragDrop._PRESSHOLDTHRESHOLD = 0; // pixels to move before drag starts\r\n    // copy styles/attributes from drag source to drag image element\r\n    MousedDragDrop._rmvAtts = 'id,class,style,draggable'.split(',');\r\n    // synthesize and dispatch an event\r\n    // returns true if the event has been handled (e.preventDefault == true)\r\n    MousedDragDrop._kbdProps = 'altKey,ctrlKey,metaKey,shiftKey'.split(',');\r\n    MousedDragDrop._ptProps = 'pageX,pageY,clientX,clientY,screenX,screenY'.split(',');\t\r\n\r\n    return MousedDragDrop\r\n});"]}